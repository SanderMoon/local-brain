#!/usr/bin/env bash

# brain-refile: Process dump items to projects
# Supports tasks (one-liners) and notes (indented blocks)

set -euo pipefail

# Source config library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Locate and source library
if [[ -f "$(dirname "$SCRIPT_DIR")/lib/brain-config.sh" ]]; then
  source "$(dirname "$SCRIPT_DIR")/lib/brain-config.sh"
elif [[ -f "$(dirname "$SCRIPT_DIR")/lib/brain/brain-config.sh" ]]; then
  source "$(dirname "$SCRIPT_DIR")/lib/brain/brain-config.sh"
elif [[ -f "$HOME/.config/brain/lib/brain-config.sh" ]]; then
  source "$HOME/.config/brain/lib/brain-config.sh"
else
  echo "Error: brain-config.sh library not found." >&2
  exit 1
fi

# Source API library
if [[ -f "$(dirname "$SCRIPT_DIR")/lib/brain-api.sh" ]]; then
  source "$(dirname "$SCRIPT_DIR")/lib/brain-api.sh"
elif [[ -f "$(dirname "$SCRIPT_DIR")/lib/brain/brain-api.sh" ]]; then
  source "$(dirname "$SCRIPT_DIR")/lib/brain/brain-api.sh"
elif [[ -f "$HOME/.config/brain/lib/brain-api.sh" ]]; then
  source "$HOME/.config/brain/lib/brain-api.sh"
fi

BRAIN_PATH=$(get_current_brain_path)
DUMP="$BRAIN_PATH/00_dump.md"
ACTIVE_DIR="$BRAIN_PATH/01_active"

show_help() {
  cat << 'EOF'
brain-refile - Process dump items to projects

Usage:
  brain refile              Interactive mode: process items one by one
  brain refile <ID> <proj>  Non-interactive: refile item by ID

Workflow:
  1. Shows each dump item (task or note)
  2. Select destination project with fuzzy finder
  3. Tasks go to project's todo.md
  4. Notes go to project's notes/ directory as separate files
  5. Repeat until done

Special options during refile:
  [SKIP]   Keep item in dump for later
  [TRASH]  Delete item permanently

Examples:
  brain refile              # Start interactive refiling
  brain refile a1b2c3 work  # Refile item a1b2c3 to 'work' project
EOF
}

# Check for help flag
if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
  show_help
  exit 0
fi

# Parse dump into items (tasks and notes with content)
# Outputs to temp files: items_file contains parsed items
# Format: START_LINE|END_LINE|TYPE|TITLE|ID
parse_dump() {
  local dump_file="$1"
  local items_file="$2"
  local content_dir="$3"

  [[ ! -f "$dump_file" ]] && return 1

  local mtime=$(stat -f %m "$dump_file" 2>/dev/null || stat -c %Y "$dump_file" 2>/dev/null)
  local line_num=0
  local in_note=false
  local note_start=0
  local note_title=""
  local note_content=""

  while IFS= read -r line || [[ -n "$line" ]]; do
    line_num=$((line_num + 1))

    # Check if line is indented (part of note content)
    if [[ "$line" =~ ^[[:space:]]{4} ]] && [[ "$in_note" == "true" ]]; then
      # Append to note content (strip 4-space indent)
      note_content+="${line:4}"$'\n'
      continue
    fi

    # If we were in a note and hit non-indented line, close the note
    if [[ "$in_note" == "true" ]]; then
      local note_id=$(echo -n "${note_start}:${note_title}:${mtime}" | compute_md5 | cut -c1-6)
      echo "${note_start}|$((line_num - 1))|note|${note_title}|${note_id}" >> "$items_file"
      # Save note content to temp file
      echo -n "$note_content" > "$content_dir/${note_id}.txt"
      in_note=false
      note_content=""
    fi

    # Skip empty lines and markdown headers
    [[ -z "${line// /}" ]] && continue
    [[ "$line" =~ ^#+ ]] && continue

    # Detect task
    if [[ "$line" =~ ^-\ \[\ \]\ (.+)$ ]]; then
      local task_content="${BASH_REMATCH[1]}"
      local task_id=$(echo -n "${line_num}:${line}:${mtime}" | compute_md5 | cut -c1-6)
      echo "${line_num}|${line_num}|task|${task_content}|${task_id}" >> "$items_file"

    # Detect note header
    elif [[ "$line" =~ ^\[Note\]\ (.+)$ ]]; then
      in_note=true
      note_start=$line_num
      note_title="${BASH_REMATCH[1]}"
      note_content=""
    fi
  done < "$dump_file"

  # Close any remaining note at end of file
  if [[ "$in_note" == "true" ]]; then
    local note_id=$(echo -n "${note_start}:${note_title}:${mtime}" | compute_md5 | cut -c1-6)
    echo "${note_start}|${line_num}|note|${note_title}|${note_id}" >> "$items_file"
    echo -n "$note_content" > "$content_dir/${note_id}.txt"
  fi
}

# Slugify text for filename
slugify() {
  echo "$1" | cut -c1-40 | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd 'a-z0-9-' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//'
}

# Refile a single item to a project
refile_item() {
  local item_type="$1"
  local item_title="$2"
  local item_id="$3"
  local project_name="$4"
  local content_dir="$5"

  local project_dir="$ACTIVE_DIR/$project_name"

  if [[ "$item_type" == "task" ]]; then
    local todo_file="$project_dir/todo.md"

    # Ensure todo.md exists
    if [[ ! -f "$todo_file" ]]; then
      cat > "$todo_file" << 'EOF'
# Tasks
## Active
## Completed
EOF
    fi

    # Append task
    echo "- [ ] $item_title" >> "$todo_file"
    echo "OK: Task → $project_name/todo.md"

  elif [[ "$item_type" == "note" ]]; then
    local notes_dir="$project_dir/notes"
    mkdir -p "$notes_dir"

    # Extract date from title if present
    local captured_date=$(date +"%Y-%m-%d")
    local clean_title="$item_title"
    if [[ "$item_title" =~ \#captured:([0-9-]+) ]]; then
      captured_date="${BASH_REMATCH[1]}"
      clean_title=$(echo "$item_title" | sed -E 's/ #captured:[0-9-]+$//')
    fi

    # Create slug
    local slug=$(slugify "$clean_title")
    [[ -z "$slug" ]] && slug="note"

    local filename="${captured_date}-${slug}.md"
    local filepath="$notes_dir/$filename"

    # Handle duplicates
    local counter=1
    while [[ -f "$filepath" ]]; do
      filename="${captured_date}-${slug}-${counter}.md"
      filepath="$notes_dir/$filename"
      counter=$((counter + 1))
    done

    # Get note content
    local content=""
    if [[ -f "$content_dir/${item_id}.txt" ]]; then
      content=$(cat "$content_dir/${item_id}.txt")
    fi

    # Create note file
    cat > "$filepath" << EOF
# $clean_title
Created: $captured_date

$content
EOF

    echo "OK: Note → $project_name/notes/$filename"
  fi
}

# Remove lines from dump
remove_lines_from_dump() {
  local start_line="$1"
  local end_line="$2"
  local temp_dump="$3"

  # Mark lines for removal (we'll process all at once later)
  for ((i=start_line; i<=end_line; i++)); do
    echo "$i" >> "$temp_dump.remove"
  done
}

# Main interactive refile
cmd_interactive() {
  # Check prerequisites
  if [[ ! -f "$DUMP" ]]; then
    echo "Error: Dump not found at $DUMP"
    exit 1
  fi

  if [[ ! -d "$ACTIVE_DIR" ]]; then
    echo "Error: Active projects directory not found: $ACTIVE_DIR"
    exit 1
  fi

  if ! command -v fzf &> /dev/null; then
    echo "Error: fzf not found"
    exit 1
  fi

  # Check for projects
  local project_count=$(find "$ACTIVE_DIR" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
  if [[ $project_count -eq 0 ]]; then
    echo "No projects found. Create one with: brain project new <name>"
    exit 1
  fi

  # Create temp directory for parsing
  local temp_dir=$(mktemp -d)
  local items_file="$temp_dir/items.txt"
  local content_dir="$temp_dir/content"
  mkdir -p "$content_dir"
  touch "$items_file"

  trap "rm -rf '$temp_dir'" EXIT

  # Parse dump
  echo "Parsing dump..."
  parse_dump "$DUMP" "$items_file" "$content_dir"

  # Check for items
  if [[ ! -s "$items_file" ]]; then
    echo "Dump is empty! Nothing to refile."
    exit 0
  fi

  local item_count=$(wc -l < "$items_file" | tr -d ' ')
  echo "Found $item_count item(s) to process"
  echo ""

  # Get projects list
  local focused=$(get_focused_project)
  local projects=$(find "$ACTIVE_DIR" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort)

  # Track processed items
  local processed_lines="$temp_dir/processed.txt"
  touch "$processed_lines"
  local processed_count=0
  local skipped_count=0
  local item_num=0

  # Process each item
  while IFS='|' read -r start_line end_line item_type item_title item_id; do
    item_num=$((item_num + 1))

    echo "----------------------------------------"
    echo "[$item_num/$item_count] $item_type:"
    echo "  $item_title"

    # Show note preview if it's a note with content
    if [[ "$item_type" == "note" ]] && [[ -f "$content_dir/${item_id}.txt" ]]; then
      local preview=$(head -3 "$content_dir/${item_id}.txt" | sed 's/^/    /')
      if [[ -n "$preview" ]]; then
        echo "$preview"
        local line_count=$(wc -l < "$content_dir/${item_id}.txt" | tr -d ' ')
        if [[ $line_count -gt 3 ]]; then
          echo "    ..."
        fi
      fi
    fi
    echo ""

    # Build project list for fzf
    local fzf_list=""
    local idx=1

    # Focused project first
    if [[ -n "$focused" ]]; then
      fzf_list+="${idx}. $focused (focused)\n"
      idx=$((idx + 1))
    fi

    # Other projects
    while IFS= read -r proj; do
      [[ "$proj" == "$focused" ]] && continue
      [[ -z "$proj" ]] && continue
      fzf_list+="${idx}. $proj\n"
      idx=$((idx + 1))
    done <<< "$projects"

    # Special options
    fzf_list+="${idx}. [SKIP]\n"
    idx=$((idx + 1))
    fzf_list+="${idx}. [TRASH]"

    # Show fzf picker
    local selected
    selected=$(echo -e "$fzf_list" | fzf --height=40% --no-sort \
      --header="Select destination (Esc to quit)" \
      --prompt="Refile $item_type > " || true)

    # Handle abort
    if [[ -z "$selected" ]]; then
      echo "Refiling aborted."
      break
    fi

    # Parse selection (remove number prefix)
    selected=$(echo "$selected" | sed 's/^[0-9]*\. //' | sed 's/ (focused)$//')

    if [[ "$selected" == "[SKIP]" ]]; then
      echo "⊘ Skipped"
      skipped_count=$((skipped_count + 1))

    elif [[ "$selected" == "[TRASH]" ]]; then
      echo "✗ Deleted"
      for ((i=start_line; i<=end_line; i++)); do
        echo "$i" >> "$processed_lines"
      done
      processed_count=$((processed_count + 1))

    else
      # Refile to project
      refile_item "$item_type" "$item_title" "$item_id" "$selected" "$content_dir"
      for ((i=start_line; i<=end_line; i++)); do
        echo "$i" >> "$processed_lines"
      done
      processed_count=$((processed_count + 1))
    fi

    echo ""
  done < "$items_file"

  # Remove processed lines from dump
  if [[ $processed_count -gt 0 ]]; then
    echo "Updating dump..."
    local new_dump="$temp_dir/new_dump.md"
    local current_line=0

    while IFS= read -r line; do
      current_line=$((current_line + 1))
      if ! grep -Fxq "$current_line" "$processed_lines" 2>/dev/null; then
        echo "$line" >> "$new_dump"
      fi
    done < "$DUMP"

    # Replace dump
    if [[ -f "$new_dump" ]]; then
      mv "$new_dump" "$DUMP"
    else
      # All items processed, create empty dump
      echo "# Dump" > "$DUMP"
    fi
  fi

  # Summary
  echo "----------------------------------------"
  echo "Summary:"
  echo "  Processed: $processed_count"
  [[ $skipped_count -gt 0 ]] && echo "  Skipped: $skipped_count"
}

# Non-interactive refile by ID
cmd_by_id() {
  local target_id="$1"
  local project_name="$2"

  # Create temp directory for parsing
  local temp_dir=$(mktemp -d)
  local items_file="$temp_dir/items.txt"
  local content_dir="$temp_dir/content"
  mkdir -p "$content_dir"
  touch "$items_file"

  trap "rm -rf '$temp_dir'" EXIT

  # Parse dump
  parse_dump "$DUMP" "$items_file" "$content_dir"

  # Find item by ID
  local found=""
  while IFS='|' read -r start_line end_line item_type item_title item_id; do
    if [[ "$item_id" == "$target_id" ]]; then
      found="$start_line|$end_line|$item_type|$item_title|$item_id"
      break
    fi
  done < "$items_file"

  if [[ -z "$found" ]]; then
    echo "Error: Item not found: $target_id" >&2
    exit 3
  fi

  # Match project
  local matched_project=$(match_project "$project_name" "$ACTIVE_DIR")
  if [[ $? -ne 0 ]]; then
    exit 4
  fi

  # Parse found item
  IFS='|' read -r start_line end_line item_type item_title item_id <<< "$found"

  # Refile
  refile_item "$item_type" "$item_title" "$item_id" "$matched_project" "$content_dir"

  # Remove from dump
  local new_dump="$temp_dir/new_dump.md"
  local current_line=0

  while IFS= read -r line; do
    current_line=$((current_line + 1))
    if [[ $current_line -lt $start_line ]] || [[ $current_line -gt $end_line ]]; then
      echo "$line" >> "$new_dump"
    fi
  done < "$DUMP"

  if [[ -f "$new_dump" ]]; then
    mv "$new_dump" "$DUMP"
  else
    echo "# Dump" > "$DUMP"
  fi
}

# Route command
if [[ $# -ge 2 ]] && [[ "${1:-}" =~ ^[a-f0-9]{6}$ ]]; then
  cmd_by_id "$1" "$2"
else
  cmd_interactive
fi
